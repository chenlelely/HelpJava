# 1.并发编程基础

**CPU**：CPU是计算机的核心，其负责承担计算机的计算任务。这里我们比喻为一个工厂

**进程**：学术上说，进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是**操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体**。我们这里将进程比喻为工厂的车间，它代表CPU所能处理的单个任务。**任一时刻，CPU总是运行一个进程，其他进程处于非运行状态**。

**线程**：在早期的操作系统中并没有线程的概念，**进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位**。**任务调度采用的是时间片轮转的抢占式调度方式**，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元。这里把线程比喻一个车间的工人，即一个车间可以允许由多个工人协同完成一个任务。

**进程和线程的区别和关系**
进程是操作系统分配资源的最小单位，线程是程序执行的最小单位。
一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；
进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)。

**调度和切换**：线程上下文切换比进程上下文切换要快得多。

**多进程和多线程**
多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。
多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。

**并发与并行**：并发是指同一个时间段内多个任务同时都在执行，并且都没有执行结束，而并行是说在单位时间内多个任务同时在执行 。

**上下文切换**：CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。

**线程上下文切换时机有**： 当前线程的 CPU 时 间片使用完处于就绪状态时；当前线程被其他线程中断时。   
**减少上下文切换的方法有**：无锁并发编程、CAS算法、使用最少线程和使用协程。

- **无锁并发编程**：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照*Hash算法取模分段*，不同的线程处理不同段的数据。
- **CAS算法**：Java的Atomic包使用CAS算法来更新数据，而不需要加锁。-
- **使用最少线程**：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。-
- **协程**：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换，即使用锁

**死锁**：死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去

- **互斥条件**： 指线程对己经获取到的资源进行排它性使用 ，
- **请求并持有条件** ： 指一个线程己经持有了至少一个 资源 ， 但又提出了新的资源请求 ，而新资源己被其他线程占有
- **不可剥夺条件** ： 指线程获取到的资源在自己使用完之前不能被其他线程抢占
- **循环等待条件** ： 指在发生死锁时 ， 必然存在一个线程→资源的环形链

**避免死锁的几个常见方法**：目前只有请求并持有和环路等待条件是可以被破坏的 。

避免一个线程同时获取多个锁。
避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。
对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。

**守护线程**：Java 中的 线程分为两类，分别为 daemon 线程（守护线程〉和 user 线程（用户线程）


**线程优先级**：要在run()方法开头设定，Thread.currentThread().setPriority(n);
