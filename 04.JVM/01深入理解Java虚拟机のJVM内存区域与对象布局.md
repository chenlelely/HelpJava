Java 程序是运行在虚拟机（ JVM ）上的，而不是直接运行在操作系统上的，所以 Java语言具有编译一 次到处运行的“跨平台特性”
![](_v_images/20191106163644475_11809.png)

# 1.Java内存区域
1. **JVM内存结构**
主要有三大块：**堆内存、方法区和栈**。堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间,默认情况下年轻代按照8:1:1的比例来分配；  
![输入图片说明](01深入理解Java虚拟机のJVM内存区域与对象布局.assets/090613_9f34c9bb_5294760.png "屏幕截图.png")  
![输入图片说明](01深入理解Java虚拟机のJVM内存区域与对象布局.assets/090649_13dda448_5294760.png "屏幕截图.png")  
**控制参数：** 没有直接设置老年代的参数， **老年代空间大小=堆空间大小-年轻代大空间大小**   
-Xms设置堆的最小空间大小。  
-Xmx设置堆的最大空间大小。  
-XX:NewSize设置新生代最小空间大小。  
-XX:MaxNewSize设置新生代最大空间大小。  
-XX:PermSize设置永久代最小空间大小。  
-XX:MaxPermSize设置永久代最大空间大小。  
-Xss设置每个线程的堆栈大小。  

2. **Java 虚拟机体系结构**
包括能装载字节码的类装载子系统、运行时数据区、执行引擎平和本地接口 
![输入图片说明](01深入理解Java虚拟机のJVM内存区域与对象布局.assets/091113_0ae717fa_5294760.png "屏幕截图.png")  
3. **运行时数据区**
为什么分区：不同的对象数据存活期不同，为了方便归类进行垃圾回收
![输入图片说明](01深入理解Java虚拟机のJVM内存区域与对象布局.assets/091048_64314791_5294760.png "屏幕截图.png")  
    1. 程序计数器：记录线程执行字节码的行号指示器。
       - 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
       - 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
       - 唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
    2. Java虚拟机栈：描述Java方法执行的内存模型： 
        - Java虚拟机栈是由一个个栈帧组成，而每个栈帧存储局部变量表、操作数栈、动态链接、方法出口等
        - 局部变量表所需内存空间在编译期完成分配，之后不会改变；局部变量表存放数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和returnAddress类型（指向了一条字节码指令的地址）。
        - 64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。**局部变量表所需的内存空间在编译期间完成分配**，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
        - 会抛出StackOverflowError和OutOfMemoryError
        如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；
        如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。
    3. 本地方法栈：为Native方法服务
        - StackOverflowError和OutOfMemoryError
    4. Java堆（GC堆）：存放对象实例、数组；
        - 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存；Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。
        - 新生代（Eden，From Survivor，To Survivor）、老年代
        - OutOfMemoryError
    5. 方法区：类信息（类的全限定名）、常量、静态变量、即时编译器编译后的代码等；
        - 很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。
        - 也需要垃圾清理
    6. 运行时常量池：存放编译期的字面量和符号引用；
        - **JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来**，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。
        - OutOfMemoryError

## 1.1 对象创建过程
![](_v_images/20191107092050075_2384.png)
*   **①类加载检查：** 虚拟机遇到一条 **new 指令**时，首先将去检查这个指令的参数是否能在常量池中定位到这个**类的符号引用**，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的**类加载过程**。
    
*   **②分配内存：** 在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。
    - **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
    
    - **TLAB：** 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配
    
    - **内存分配的两种方式：（补充内容，需要掌握）**  
    **分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择那种分配方式由 Java 堆是否规整决定**。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的
    
    - **内存分配并发问题(补充内容，需要掌握:** 在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全
    
*   **③初始化零值：** 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
    
*   **④设置对象头：** 初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
    
*   **⑤执行 init 方法：** 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后接着执行 <init> 方法，将**对象属性值进行显示初始化并执行构造方法**（调用子类<init> 方法之前会先调用父类<init> 方法）  

**存在继承的情况下，初始化顺序为：**
1.  父类（静态变量、静态语句块）
2.  子类（静态变量、静态语句块）
3.  父类（实例变量、普通语句块）——>父类（构造函数）
4.  子类（实例变量、普通语句块）——>子类（构造函数）

## 1.2 对象的内存布局：
**对象头、实例数据、对齐填充**

*   对象头：
    - 运行时数据/MarkWord（32bit/64bit）：HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；
    - 类型指针：对象指向他的类元数据的指针
    
*   实例数据：对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。
    
*   对齐填充：占位符（对象大小必须是8字节的整数倍）
    

## 1.3 对象的访问

**Java程序需要通过栈上的reference操作具体对象**

*   **句柄：**   如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；
    
*    ![](https://images.gitee.com/uploads/images/2019/1104/094324_2f0ef550_5294760.png)
    
*   **直接指针：**  如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。
    
*   ![](https://images.gitee.com/uploads/images/2019/1104/094324_168d3431_5294760.png)
    
*   这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

## 1.4 String 类和常量池

**1 String 对象的两种创建方式：**
```
String str1 = "abcd";
String str2 = new String("abcd");  
System.out.println(str1==str2);//false
```
第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。

![](https://images.gitee.com/uploads/images/2019/1104/094847_6297a6fc_5294760.png)

**2 String 类型的常量池比较特殊。它的主要使用方法有两种：**
直接使用**双引号**声明出来的 String 对象会直接存储在**常量池**中。   
如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern() 方法。
    - **String.intern()**是一个 Native 方法，它的作用是：**如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。**

```
String s1 = new String("计算机");
String s2 = s1.intern();
String s3 = "计算机";
System.out.println(s2);//计算机
System.out.println(s1 == s2);//false，因为一个是堆内存中的String对象一个是常量池中的String对象
System.out.println(s3 == s2);//true，因为两个都是常量池中的String对象
```

**3 String 字符串拼接**
尽量避免使用引用进行多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。
```
String str1 = "str";
String str2 = "ing";
String str3 = "str" + "ing";//常量池中的对象
String str4 = str1 + str2; //在堆上创建的新的对象      
String str5 = "string";//常量池中的对象
System.out.println(str3 == str4);//false
System.out.println(str3 == str5);//true
System.out.println(str4 == str5);//false
```

![](https://images.gitee.com/uploads/images/2019/1104/094847_524fe5de_5294760.png)

> **String s1 = new String("abc");这句话创建了几个对象？**  
> 创建了两个对象。先有字符串"abc"放入常量池，然后 new 了一份字符串"abc"放入Java堆(字符串常量"abc"在编译期就已经确定放入常量池，而 Java 堆上的"abc"是在运行期初始化阶段才确定)，然后 Java 栈的 str1 指向Java堆上的"abc"。

## 1.5 Integer常量

1. Integer i = value;如果i是在`-128到127`之间，不会去堆中创建对象，而是直接返回IntegerCache中的值;如果值不在上面范围内则会从堆中创建对象。`"=" 走的是valueOf()方法,valueOf(int)会走缓存`。
2. Integer i2 = new Integer(xxxx);不管参数的value是多少都会从堆中创建对象，与IntegerCache没关系。
3.  **Integer.valueOf()** 返回一个表示指定的 int 值的`Integer 实例`。内部是“如果i在-128~127之间直接返回IntegerCache中的Integer实例，否则使用构造方法 Integer(int)创建新的实例”，该方法有可能通过缓存经常请求的值而显著提高空间和时间性能。
4.  Integer.parseInt(string s)的作用就是把字符串s解析成有符号的`int基本类型`
5.  Integer.valueOf(s)把字符串s解析成Integer对象类型，返回的integer包装类型 可以调用对象中的方法。

![](https://images.gitee.com/uploads/images/2019/1104/094848_d3d5e448_5294760.png)