# Filter

## 什么是过滤器

过滤器 JavaWeb 三大组件之一， 它与 Servlet 很相似！ 不过过滤器是用来拦截请求的，而不是处理请求的。

当用户请求某个 Servlet 时， 会**先执行部署在这个请求上的 Filter**， 如果 Filter“放行”，那么会继承执行用户请求的 Servlet； 如果 Filter 不“ 放行”， 那么就不会执行用户请求的Servlet。

其实可以这样理解， 当用户请求某个 Servlet 时， Tomcat 会去执行注册在这个请求上的Filter， 然后是否“放行” 由 Filter 来决定。 可以理解为， Filter 来决定是否调用 Servlet！ 当执行完成 Servlet 的代码后， 还会执行 Filter 后面的代码 。 

![image-20200308103739639](02Filter.assets/image-20200308103739639.png)

## 过滤器的生命周期

- `init(FilterConfig)`:在服务器启动时会创建 Filter实例，并且每个类型的Filter只创建一个实例，从此不再创建！在创建完Filter实例后，会马上调用`init()`方法完成初始化工作，这个方法只会被执行一次；
- `doFilter(ServletRequest req,ServletResponse res,FilterChain chain)`:这个方法会在用户每次访问“目标资源`（<url->pattern>index.jsp</url-pattern>)`时执行，如果需要“放行”，那么需要调用FilterChain的`doFilter(ServletRequest,ServletResponse)`方法，如果不调用FilterChain的doFilter()方法，那么目标资源将无法执行；
- `destroy()`:服务器会在创建 Filter对象之后，把Filter放到缓存中一直使用，通常不会销毁它。一般会在服务器关闭时销毁Filter对象，在销毁Filter对象之前，服务器会调用Filter对象的 destory()方法。
- 单例，同Servlet一致

## FilterConfig
Filter 接口中的init()方法的参数类型为FilterConfig类型。它的功能与ServletConfig相似，与web.xml文件中的配置信息对应。下面是FilterConfig的功能介绍：

- ServletContext getServletContext():获取 ServletContext的方法；
- String getFilterName()：获取Filter的配置名称；与`<filter-name>`元素对应；
- String getlnitParameter(String name)：获取Filter的初始化配置，与`<init-param>`元素对应；
- Enumeration getlnitParameterNames():获取所有初始化参数的名称。

![image-20200308104657001](02Filter.assets/image-20200308104657001.png)

## FilterChain
doFilter()方法的参数中有一个类型为FilterChain的参数，它只有一个方法：
doFilter(ServletRequest,ServletResponse,FilterChain)。

前面我们说doFilter()方法的放行，让请求流访问目标资源！但这么说不严谨，其实调用该方法的意思是，“我（当前Filter)”放行了，但不代表其他人（其他过滤器）也放行。

如果当前过滤器是最后一个过滤器，那么调用chain.doFilter()方法表示执行目标资源，而不是最后一个过滤器，那么chain.doFilter()表示执行下一个过滤器的doFilter()方法。

## 四种拦截方式

其实过滤器有四种拦截方式！分别是：REQUEST、FORWARD、INCLUDE、ERROR。

- REQUEST:直接访问目标资源时执行过滤器。包括：在地址栏中直接访问、表单提交、超链接、重定向，只要在地址栏中可以看到目标资源的路径，就是REQUEST；（不执行过滤器）
- FORWARD：转发访问执行过滤器。包括RequestDispatcher#forward(）方法、`<jsp:forward>`标签都是转发访问：（不执行过滤器）
- INCLUDE：包含访问执行过滤器。包括RequestDispatcher#include方法、`<jsp：include>`标签都是包含访问；
- ERROR：当目标资源在web.xml中配置为`<error-page>`中时，并且真的出现了异常，转发到目标资源时，会执行过滤器。

## 过滤器的应用场

1. 执行目标资源之前做预处理工作，例如**设置编码**，这种通常都会放行，只是在目标资源执行之前做一些准备工作；
   几乎是所有的Sevlet中都需要写request.setCharacterEndoing0可以把它放入到一个Filter中
2. 通过条件判断是否放行，例如校验当前**用户是否已经登录**，或者用户lP是否已经被禁用；
3. 在目标资源执行后，做一些后续的特殊处理工作，例如把目标资源输出的数据进行处理；