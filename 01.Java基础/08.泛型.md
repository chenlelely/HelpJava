## 8.1 类型参数：T

**泛型就是类型参数化，处理的数据类型不是固定的，而是作为参数传入**。Java泛型是通过擦除实现的，类定义中的类型参数如T会被替换为Object，在程序运行过程中，不知道泛型的实际类型参数

**泛型类**：**类型参数放在类名之后**

```java
public class Pair<U,V>{
    U first;
    V second;
    public Pair(U first,V second){
        this.first = first;
        this.second = second;
    }
}
Pair<String,Integer> pair = new Pair<>("laomu",20);
```



**泛型方法**：**类型参数放在返回值前**；与泛型类一样，类型参数可以有多个，以逗号分隔，比如：￼

```java
public static <U,V> Pair<U,V> makePair(U first, V second){￼ 
    Pair<U,V> pair = new Pair<>(first, second);￼ 
    return pair;￼ 
}
```

**泛型接口**：和泛型类差不多

### 类型参数限定 

1. 上界为某个具体类：`<T extends Number>`

2. 上界为某个接口:`<T extends Comparable<T>>`,这里因为Comparable是一个泛型接口，它也需要一个类型参数

   1. ````java
      public static <T extends Comparable<T>> T max(T[] arr){//主体代码}
      ````

   2. 这种形式称为递归类型限制，可以这么解读：T表示一种数据类型，必须实现Comparable接口，且必须可以与相同类型的元素进行比较。

3. 上界为其他类型参数：上面的限定都是指定了一个明确的类或接口，Java支持一个类型参数以另一个类型参数作为上界，`<T extends E>`。

泛型是计算机程序中一种重要的思维方式，它将数据结构和算法与数据类型相分离，使得同一套数据结构和算法能够应用于各种数据类型，而且可以保证类型安全，提高可读性

## 8.2 通配符:?

![image-20200301190818665](08.泛型.assets/image-20200301190818665.png)

这个方法没有定义类型参数，==c的类型是DynamicArray<? extends E>, ？表示通配符，<? extends E>表示有限定通配符，匹配E或E的某个子类型，具体什么子类型是未知的。==
使用这个方法的代码不需要做任何改动，还可以是：
![image-20200301190908479](08.泛型.assets/image-20200301190908479.png)

这里，E是Number类型，DynamicArray<? extends E>可以匹配DynamicArray<Integer>。

**`<T extends E>`和`<? extends E>`到底有什么关系？**  它们用的地方不一样，我们解释一下：  

- <T extends E>用于**定义类型参数**，它声明了一个类型参数T，可放在泛型类定义中类名后面、泛型方法返回值前面。
- <? extends E>用于**实例化类型参数**，它用于实例化泛型变量中的类型参数，只是这个具体类型是未知的，只知道它是E或E的某个子类型。

### 8.2.1 理解通配符

除了有限定通配符，还有一种通配符，形如`DynamicArray<?>`，称为**无限定通配符**。  
无限定通配符形式也可以改为使用类型参数:

![image-20200301191808457](08.泛型.assets/image-20200301191808457.png)![image-20200301191822577](08.泛型.assets/image-20200301191822577.png)

> 通配符形式更为简洁，返回值之前不需要类型参数。虽然通配符形式更为简洁，但上面两种通配符都有一个重要的限制：**只能读，不能写。**

![image-20200301192207936](08.泛型.assets/image-20200301192207936.png)

>为什么呢？问号就是表示类型安全无知，?extends Number表示是Number的某个子类型，但不知道具体子类型，如果允许写入，Java就无法确保类型安全性，所以干脆禁止

**泛型方法到底应该用通配符的形式还是加类型参数。两者到底有什么关系？**

- 通配符形式都可以用类型参数的形式来替代，通配符能做的，用类型参数都能做。
- 通配符形式可以减少类型参数，形式上往往更为简单，可读性也更好，所以，能用通配符的就用通配符。
- 如果类型参数之间有依赖关系，或者返回值依赖类型参数，或者需要写操作，则只能用类型参数。
- 通配符形式和类型参数往往配合使用，比如，定义必要的类型参数，使用通配符表达依赖，并接受更广泛的数据类型。

### 8.2.3 超类型通配符

还有一种通配符，与形式`<? extends E>`正好相反，它的形式为`<?super E>`，称为超类型通配符，表示E的某个父类型,**为了方便写入**。

错误的方式：![image-20200301193341445](08.泛型.assets/image-20200301193341445.png)

正确的方式：![image-20200301193424108](08.泛型.assets/image-20200301193424108.png)

>对于有限定的通配符形式<? extends E>，可以用类型参数限定替代，但是对于类似上面的**超类型通配符，则无法用类型参数替代**。

### 8.2.4 <? >、<? super E>和<? extends E>

1. 它们的目的都是为了使方法接口更为灵活，可以接受更为广泛的类型。
2. <? super E>**用于灵活写入或比较**，使得对象可以写入父类型的容器，使得父类型的比较方法可以应用于子类对象，它不能被类型参数形式替代。
3. <? >和<? extends E>**用于灵活读取**，使得方法可以读取E或E的任意子类型的容器对象，它们可以用类型参数的形式替代，但通配符形式更为简洁。

## 8.3 泛型的局限

### 8.3.1 使用泛型类、方法和接口

使用泛型类、方法和接口时，有一些值得注意的地方，比如：

- 基本类型不能用于实例化类型参数。
- 运行时类型信息不适用于泛型。
- **类型擦除**可能会引发一些冲突。

Java中，因为类型参数会被替换为Object，所以Java泛型中不能使用基本数据类型，但是**可以使用基本类型的包装类**。

> 在内存中每个类都有一份**类型信息**，而每个对象也都保存着其**对应类型信息的引用**。
>
> 在Java中，这个类型信息也是一个**对象**，它的类型为**Class**, Class本身也是一个**泛型类**，每个类的类型对象可以通过`<类名>.class`的方式引用，比如`String. class`、`Integer.class`。这个类型对象也可以通过对象的`getClass()`方法获得.
>
> 泛型对象的类型对象和原始对象的类型对象一样

### 8.3.2 定义泛型类、方法和接口

在定义泛型类、方法和接口时，也有一些需要注意的地方，比如：

- 不能通过类型参数创建对象。
- 泛型类类型参数不能用于静态变量和方法。
- 了解多个类型限定的语法。

1. 如果确实希望根据类型创建对象呢？需要设计API接受类型对象，即Class对象，并使用Java中的反射机制。  
   ![image-20200301195215479](08.泛型.assets/image-20200301195215479.png)

2. 对于泛型类声明的类型参数，可以在实例变量和方法中使用，但在静态变量和静态方法中是不能使用的。