## 2.1 整数的二进制表示

二进制使用最高位表示符号位，**用1表示负数，用0表示正数**。但哪个是最高位呢？整数有4种类型byte、short、int、long，分别占1、2、4、8个字节，即分别占8、16、32、64位，每种类型的符号位都是其最左边的一位

**补码表示法**：补码表示就是在对应正数原码表示的基础上**取反然后加1**。取反就是将0变为1,1变为0。负数的二进制表示就是对应的正数的补码表示

> 给定一个负数的二进制表示，要想知道它的十进制值，可以采用相同的补码运算。比如：10010010，首先取反，变为01101101，然后加1，结果为01101110，它的十进制值为110，所以原值就是-110。直觉上，应该是先减1，然后再取反，但计算机只能做加法，而补码的一个良好特性就是，**对负数的补码表示做补码运算就可以得到其对应正数的原码，正如十进制运算中负负得正一样**。

对于byte类型，正数最大表示是01111111，即127，负数最小表示（绝对值最大）是10000000，即-128，表示范围就是-128～127

>计算机其实只能做加法，1-1其实是1+(-1)。如果用原码表示，计算结果是不对的，比如：￼ 
>1 -> 00000001￼ -1 -> 10000001￼ + ------------------￼ -2 -> 10000010用符合直觉的原码表示，1-1的结果是-2，如果是补码表示：￼ 1 -> 00000001￼ -1 -> 11111111￼ + ------------------￼ 0 -> 00000000结果是正确的。再如，5-3：￼ 5 -> 00000101￼ -3 -> 11111101￼ + ------------------￼ 2 -> 00000010结果也是正确的

为什么正数的运算结果可能出现负数了。当计算结果超出表示范围的时候，最高位往往是1，然后就会被看作负数

十六进制直接写常量数字，在数字前面加`0x`即可 ;Java 7开始支持二进制常量，在前面加`0b`或`0B`即可 ;在Java中，可以方便地使用Integer和Long的方法查看整数的二进制和十六进制表示

**位运算**:有移位运算和逻辑运算
移位有以下几种。
1）左移：操作符为<  
2）无符号右移：操作符为>>>，向右移动，右边的舍弃掉，左边补0。  
3）有符号右移：操作符为>>，向右移动，右边的舍弃掉，左边补什么取决于原来最高位是什么，原来是1就补1，原来是0就补0，将二进制看作整数，右移1位相当于除以2。  
逻辑运算有以下几种。  
按位与&：两位都为1才为1。  
按位或|：只要有一位为1，就为1。  
按位取反~:1变为0,0变为1。  
按位异或^：相异为真，相同为假。      

## 2.2 小数的二进制表示

计算机中可以精确表示为2的某次方之和的数可以精确表示，其他数则不能精确表示。 

如果真的需要比较高的精度，一种方法是将小数转化为整数进行运算，运算结束后再转化为小数；另一种方法是使用十进制的数据类型，这个并没有统一的规范。在Java中是**BigDecimal**，运算更准确 

为什么要叫浮点数呢？这是由于小数的二进制表示中，表示那个小数点的时候，点不是固定的，而是浮动的。

## 2.3 字符的编码与乱码

编码有两大类：一类是非Unicode编码；另一类是Unicode编码

- 非Unicode编码，包括ASCII、ISO 8859-1、Windows-1252、GB2312、GBK、GB18030和Big5。

128个字符用7位刚好可以表示，计算机存储的最小单位是byte，即8位，ASCII码中最高位设置为0，用剩下的7位表示字符。这7位可以看作数字0～127, **ASCII码规定了从0～127的每个数字代表什么含义**。

GB2312固定使用**两个字节表示汉字**，在这两个字节中，最高位都是1，如果是0，就认为是ASCII字符。在这两个字节中，其中高位字节范围是0xA1～0xF7，低位字节范围是0xA1～0xFE。

> ASCII码是基础，使用一个字节表示，最高位设为0，其他7位表示128个字符。其他编码都是兼容ASCII的，最高位使用1来进行区分。

**Unicode主要做了这么一件事，就是给所有字符分配了唯一数字编号**。它并没有规定这个编号怎么对应到二进制表示，这是与上面介绍的其他编码不同的，<u>其他编码都既规定了能表示哪些字符，又规定了每个字符对应的二进制是什么</u>，而Unicode本身只规定了每个字符的数字编号是多少。  
**那编号怎么对应到二进制表示呢？有多种方案，主要有UTF-32、UTF-16和UTF-8。**

> UTF-16使用变长字节表示：
> 1）对于编号在U+0000～U+FFFF的字符（常用字符集），直接用**两个字节**表示。需要说明的是，U+D800～U+DBFF的编号其实是没有定义的。
> 2）字符值在U+10000～U+10FFFF的字符（也叫做增补字符集），需要用**4个字节**表示

> 对于一个Unicode编号，具体怎么编码呢？首先将其看作整数，转化为二进制形式（去掉高位的0），然后将二进制位从右向左依次填入对应的二进制格式x中，填完后，如果对应的二进制格式还有没填的x，则设为0。
>
> Unicode给世界上所有字符都规定了一个统一的编号，编号范围达到110多万，但大部分字符都在65 536以内。Unicode本身没有规定怎么把这个编号对应到二进制形式。UTF-32/UTF-16/UTF-8都在做一件事，就是把Unicode编号对应到二进制形式，其对应方法不同而已

**编码转换的具体过程可以是**：一个字符从A编码转到B编码，先找到字符的A编码格式，通过A的映射表找到其Unicode编号，然后通过Unicode编号再查B的映射表，找到字符的B编码格式。

## 2.4 char的真正含义

char用于表示一个字符，这个字符可以是中文字符，也可以是英文字符。赋值时把常量字符用单引号括起来

在Java内部进行字符处理时，采用的都是Unicode，具体编码格式是UTF-16BE。简单回顾一下，UTF-16使用两个或4个字节表示一个字符，Unicode编号范围在65 536以内的占两个字节，超出范围的占4个字节，BE就是先输出高位字节，再输出低位字节，这与整数的内存表示是一致的

> 十六进制的一位正好是8位一个字节，因此两位十六进制数可以表示一个字符

char本质上是一个固定占用两个字节的无符号正整数，这个正整数对应于Unicode编号，用于表示那个Unicode编号对应的字符。由于固定占用两个字节，char只能表示Unicode编号在65 536以内的字符，而不能表示超出范围的字符

char有多种赋值方式

````java
char c = 'A'￼ 
char c = '马'￼
char c = 39532
char c = 0x9a6c￼
char c = '\u9a6c'
````

>第2种赋值方式和第3种赋值方式是一样的。  
>第3种赋值方式是直接将十进制的常量赋给字符。  
>第4种赋值方式是将十六进制常量赋给字符  
>第5种赋值方式是按Unicode字符形式。  
>所以，第2、3、4、5种赋值方式都是一样的，本质都是将Unicode编号39 532赋给了字符。

由于char本质上是一个整数，所以可以进行整数能做的一些运算，在进行运算时会被看作int，但由于char占两个字节，运算结果不能直接赋值给char类型，需要进行强制类型转换，这和byte、short参与整数运算是类似的。char类型的比较就是其Unicode编号的比较。