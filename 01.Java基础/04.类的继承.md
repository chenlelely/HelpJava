## 4.1 基本概念

继承，是因为子类继承了父类的属性和行为，父类有的属性和行为子类都有。但子类可以增加子类特有的属性和行为，某些父类有的行为，子类的实现方式可能与父类也不完全一样。  
使用继承一方面可以复用代码，公共的属性和行为可以放到父类中，而子类只需要关注子类特有的就可以了；另一方面，不同子类的对象可以更为方便地被统一处理。

1）Java使用extends关键字表示继承关系，一个类最多只能有一个父类；  
2）子类不能直接访问父类的私有属性和方法。比如，在Circle中，不能直接访问Shape的私有实例变量color；  
3）除了私有的外，子类继承了父类的其他属性和方法

子类对象赋值给父类引用变量，这叫**向上转型**，转型就是转换类型，向上转型就是转换为父类类型。

变量shape可以引用任何Shape子类类型的对象，这叫多态，即一种类型的变量，可引用多种实际类型对象。这样，对于变量shape，它就有两个类型：类型Shape，我们称之为shape的**静态类型**；类型Circle/Line/ArrowLine，我们称之为shape的**动态类型**。在ShapeManager的draw方法中，shapes[i].draw()调用的是其<u>对应动态类型的draw方法</u>，这称之为方法的**动态绑定**。

多态和动态绑定是计算机程序的一种重要思维方式，使得操作对象的程序不需要关注对象的实际类型，从而可以统一处理不同对象，但又能实现每个对象的特有行为

1）每个类有且只有一个父类，没有声明父类的，其父类为Object，子类继承了父类非private的属性和方法，可以增加自己的属性和方法，以及重写父类的方法实现。  
2）new过程中，父类先进行初始化，可通过super调用父类相应的构造方法，没有使用super的情况下，调用父类的默认构造方法。  
3）子类变量和方法与父类重名的情况下，可通过super强制访问父类的变量和方法。  
4）子类对象可以赋值给父类引用变量，这叫多态；实际执行调用的是子类实现，这叫动态绑定。

## 4.2 继承的细节

父类没有默认构造方法时候，它的任何子类都必须在构造方法中通过super调用Base的带参数构造方 

当通过变量b（父类静态类型）访问实例变量、静态变量、静态方法时，访问的是Base的变量和方法，当通过c（子类静态类型）访问相同的实例变量、静态变量、静态方法时，访问的是Child的变量和方法，这称之为静态绑定，即访问绑定到变量的静态类型。  
**静态绑定在程序编译阶段即可决定，而动态绑定则要等到程序运行时。==实例变量、静态变量、静态方法、private方法==都是静态绑定的，其他的方法是动态绑定的**。 

**重载**是指方法名称相同但参数签名不同（参数个数、类型或顺序不同），**重写**是指子类重写与父类相同参数签名的方法。 

有多个重名函数的时候，在决定要调用哪个函数的过程中，**首先是按照参数类型进行匹配的**，换句话说，寻找在所有重载版本中最匹配的，**然后才看变量的动态类型，进行动态绑定** 

一个父类的变量能不能转换为一个子类的变量，取决于这个父类变量的动态类型（即引用的对象类型）是不是这个子类或这个子类的子类。  
给定一个父类的变量能不能知道它到底是不是某个子类的对象，从而安全地进行类型转换呢？答案是可以，通过instanceof关键字

重写方法时，一般并不会修改方法的可见性。但我们还是要说明一点，**重写时，子类方法不能降低父类方法的可见性**。不能降低是指，父类如果是public，则子类也必须是public，父类如果是protected，子类可以是protected，也可以是public，即子类可以升级父类方法的可见性但不能降低

**继承反映的是“is-a”的关系**，即子类对象也属于父类，子类必须支持父类所有对外的行为，将可见性降低就会减少子类对外的行为，从而破坏“is-a”的关系，但子类可以增加父类的行为，所以提升可见性是没有问题的

不希望父类方法被子类重写，有的时候甚至不希望类被继承，可以通过final关键字实现。final关键字可以修饰变量，而这是final的另一种用法。一个Java类，默认情况下都是可以被继承的，但**加了final关键字之后就不能被继承了**

## 4.3 继承实现的基本原理

在Java中，所谓类的加载是指将类的相关信息加载到内存。在Java中，类是动态加载的，当第一次使用这个类的时候才会加载，加载一个类时，会查看其父类是否已加载，如果没有，则会加载其父类。

1. 一个类的信息主要包括以下部分：
   1. 类变量（静态变量）；
   2. 类初始化代码；
   3. 类方法（静态方法）；
   4. 实例变量；
   5. 实例初始化代码；
   6. 实例方法；
   7. 父类信息引用。
2. 类初始化代码包括：
   1. 定义静态变量时的赋值语句；
   2. 静态初始化代码块。
3. 实例初始化代码包括：
   1. 定义实例变量时的赋值语句；
   2. 实例初始化代码块；
   3. 构造方法。
4. 类加载过程包括：
   1. 分配内存保存类的信息；
   2. 给类变量赋默认值；
   3. 加载父类；
   4. 设置父子关系；
   5. 执行类初始化代码。

> 注意，类初始化代码，是先执行父类的，再执行子类的。不过，父类执行时，子类静态变量的值也是有的，是默认值
>
> 内存分为栈和堆，栈存放函数的局部变量，而堆存放动态分配的对象，还有一个内存区，存放类的信息，这个区在Java中称为方法区

在类加载之后，new Child()就是创建Child对象，创建对象过程包括：  
1）分配内存；  
2）对所有实例变量赋默认值；  
3）执行实例初始化代码。  
分配的内存包括本类和所有父类的实例变量，但不包括任何静态变量。实例初始化代码的执行从父类开始，再执行子类的。但在任何类执行初始化代码之前，所有实例变量都已设置完默认值。

分配的内存包括本类和所有父类的实例变量，但不包括任何静态变量。实例初始化代码的执行从父类开始，再执行子类的。但在任何类执行初始化代码之前，所有实例变量都已设置完默认值。

每个对象除了保存类的实例变量之外，还保存着实际类信息的引用

**方法调用的过程** 寻找要执行的实例方法的时候，是从对象的实际类型信息开始查找的，找不到的时候，再查找父类类型信息。

## 4.4 为什么说继承是把双刃剑

封装就是隐藏实现细节，提供简化接口。使用者只需要关注怎么用，而不需要关注内部是怎么实现的。

继承可能破坏封装是因为子类和父类之间可能存在着实现细节的依赖。子类在继承父类的时候，往往不得不关注父类的实现细节，而父类在修改其内部实现的时候，如果不考虑子类，也往往会影响到子类。

子类和父类之间是细节依赖，子类扩展父类，仅仅知道父类能做什么是不够的，还需要知道父类是怎么做的，而父类的实现细节也不能随意修改，否则可能影响子类。

父类不能随意增加公开方法，因为给父类增加就是给所有子类增加，而子类可能必须要重写该方法才能确保方法的正确性。  
总结一下：对于子类而言，通过继承实现是没有安全保障的，因为父类修改内部实现细节，它的功能就可能会被破坏；而对于基类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由。

我们先来看怎么避免继承，有三种方法：  
❑ 使用final关键字；  
❑ 优先使用组合而非继承；  
❑ 使用接口。

> final方法不能被重写，final类不能被继承  
> 给方法加final修饰符，父类就保留了随意修改这个方法内部实现的自由，使用这个方法的程序也可以确保其行为是符合父类声明的  
>
> 使用组合可以抵挡父类变化对子类的影响，从而保护子类，应该优先使用组合