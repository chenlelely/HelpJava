## 4.1 基本概念

> 继承：如果多个类的某个部分的功能相同，那么可以抽象出一个类出来，把他们的相同部分都放到父类里，让他们都继承这个类。
>
> 实现：如果多个类处理的目标是一样的，但是处理的方法方式不同，那么就定义一个接口，也就是一个标准，让他们的实现这个接口，各自实现自己具体的处理方法来处理那个目标
>
> **所以，继承的根本原因是因为要*复用*，而实现的根本原因是需要定义一个*标准*。**

继承，是因为子类继承了父类的属性和行为，父类有的属性和行为子类都有。但子类可以增加子类特有的属性和行为，某些父类有的行为，子类的实现方式可能与父类也不完全一样。 

使用继承一方面可以复用代码，公共的属性和行为可以放到父类中，而子类只需要关注子类特有的就可以了；另一方面，不同子类的对象可以更为方便地被统一处理。

1. Java使用`extends`关键字表示继承关系，一个类最多只能有一个父类；  
2. 子类不能直接访问父类的私有属性和方法。比如，在Circle中，不能直接访问Shape的私有实例变量color；  
3. 除了私有的外，子类继承了父类的其他属性和方法

子类对象赋值给父类引用变量，这叫**向上转型**，转型就是转换类型，向上转型就是转换为父类类型。

> 父类型变量shape可以引用任何Shape子类类型的对象，这叫多态，即一种类型的变量，可引用多种实际类型对象。这样，对于变量shape，它就有两个类型：
>
> 类型Shape，我们称之为shape的**静态类型**；
>
> 类型Circle/Line/ArrowLine，我们称之为shape的**动态类型**。
>
> 在ShapeManager的draw方法中，shapes[i].draw()调用的是其<u>对应动态类型的draw方法</u>，这称之为方法的**动态绑定**。

多态和动态绑定是计算机程序的一种重要思维方式，使得操作对象的程序不需要关注对象的实际类型，从而可以统一处理不同对象，但又能实现每个对象的特有行为

1. 每个类有且只有一个父类，没有声明父类的，其父类为Object，子类继承了父类非private的属性和方法，可以增加自己的属性和方法，以及重写父类的方法实现。  
2. new过程中，父类先进行初始化，可通过super调用父类相应的构造方法，没有使用super的情况下，调用父类的默认构造方法。
3. 子类变量和方法与父类重名的情况下，可通过super强制访问父类的变量和方法。  
4. 子类对象可以赋值给父类引用变量，这叫多态；实际执行调用的是子类实现，这叫动态绑定。

## 4.2 继承的细节

父类没有默认构造方法时候，它的任何子类都必须在构造方法中通过`super`调用父类的带参数构造方 

当通过变量b（父类静态类型）访问实例变量、静态变量、静态方法时，访问的是Base的变量和方法，当通过c（子类静态类型）访问相同的实例变量、静态变量、静态方法时，访问的是Child的变量和方法，这称之为静态绑定，即访问绑定到变量的静态类型。  

**静态绑定在程序编译阶段即可决定，而动态绑定则要等到程序运行时。==实例变量、静态变量、静态方法、private方法==都是静态绑定的，其他的方法是动态绑定的**。 

**重载**是指方法名称相同但参数签名不同（参数个数、类型或顺序不同），**重写**是指子类重写与父类相同参数签名的方法。 

有多个重名函数的时候，在决定要调用哪个函数的过程中，**首先是按照参数类型进行匹配的**，换句话说，寻找在所有重载版本中最匹配的，**然后才看变量的动态类型，进行动态绑定** 

给定一个父类的变量能不能知道它到底是不是某个子类的对象，从而安全地进行类型转换呢？答案是可以，通过`instanceof`关键字；一个父类的变量能不能转换为一个子类的变量，取决于这个父类变量的动态类型（即引用的对象类型）是不是这个子类或这个子类的子类。  

**继承反映的是“is-a”的关系**，即子类对象也属于父类，子类必须支持父类所有对外的行为，将可见性降低就会减少子类对外的行为，从而破坏“is-a”的关系，但子类可以增加父类的行为，所以提升可见性是没有问题的

不希望父类方法被子类重写，有的时候甚至不希望类被继承，可以通过·`final`关键字实现。final关键字可以修饰变量，而这是final的另一种用法。一个Java类，默认情况下都是可以被继承的，但**加了final关键字之后就不能被继承了**

> 重写的条件：
>
> - 参数列表必须完全与被重写方法的相同；
> - 返回类型必须完全与被重写方法的返回类型相同；
> - 访问级别的限制性一定不能比被重写方法的强；
> - 访问级别的限制性可以比被重写方法的弱；
> - 重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常
> - 重写的方法能够抛出更少或更有限的异常（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明）
> - 不能重写被标示为final的方法；
> - 如果不能继承一个方法，则不能重写这个方法。
>
> 重载的条件：
>
> - 被重载的方法必须改变参数列表；
> - 被重载的方法可以改变返回类型；
> - 被重载的方法可以改变访问修饰符；
> - 被重载的方法可以声明新的或更广的检查异常；
> - 方法能够在同一个类中或者在一个子类中被重载。

## 4.3 继承实现的基本原理

在Java中，所谓类的加载是指将类的相关信息加载到内存。在Java中，**类是动态加载的，当第一次使用这个类的时候才会加载**，加载一个类时，会查看其父类是否已加载，如果没有，则会加载其父类。

1. 一个类的信息主要包括以下部分：
   1. 类变量（静态变量）；
   2. 类初始化代码；
   3. 类方法（静态方法）；
   4. 实例变量；
   5. 实例初始化代码；
   6. 实例方法；
   7. 父类信息引用。
2. 类初始化代码包括：
   1. 定义静态变量时的赋值语句；
   2. 静态初始化代码块。
3. 实例初始化代码包括：
   1. 定义实例变量时的赋值语句；
   2. 实例初始化代码块；
   3. 构造方法。
4. 类加载过程包括：
   1. 分配内存保存类的信息；
   2. 给类变量赋默认值；
   3. 加载父类；
   4. 设置父子关系；
   5. 执行类初始化代码。

> 注意，类初始化代码，是先执行父类的，再执行子类的。不过，父类执行时，子类静态变量的值也是有的，是默认值
>
> 内存分为栈和堆，栈存放函数的局部变量，而堆存放动态分配的对象，还有一个内存区，存放类的信息，这个区在Java中称为方法区

在类加载之后，new Child()就是创建Child对象，创建对象过程包括：  

1. 分配内存； 
2. 对所有实例变量赋默认值；  
3. 执行实例初始化代码。  

分配的内存包括本类和所有父类的实例变量，但不包括任何静态变量。实例初始化代码的执行从父类开始，再执行子类的。但在任何类执行初始化代码之前，所有实例变量都已设置完默认值。

每个对象除了保存类的实例变量之外，还保存着实际类信息的引用

**方法调用的过程** 寻找要执行的实例方法的时候，**是从对象的实际类型信息开始查找的，找不到的时候，再查找父类类型信息。**

## 4.4 为什么说继承是把双刃剑

封装就是隐藏实现细节，提供简化接口。使用者只需要关注怎么用，而不需要关注内部是怎么实现的。

继承可能破坏封装是因为子类和父类之间可能存在着实现细节的依赖。子类在继承父类的时候，往往不得不关注父类的实现细节，而父类在修改其内部实现的时候，如果不考虑子类，也往往会影响到子类。

子类和父类之间是细节依赖，子类扩展父类，仅仅知道父类能做什么是不够的，还需要知道父类是怎么做的，而父类的实现细节也不能随意修改，否则可能影响子类。

父类不能随意增加公开方法，因为给父类增加就是给所有子类增加，而子类可能必须要重写该方法才能确保方法的正确性。 

总结一下：对于子类而言，通过继承实现是没有安全保障的，因为父类修改内部实现细节，它的功能就可能会被破坏；而对于基类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由。

我们先来看怎么避免继承，有三种方法：  

1. 使用final关键字；  
2. 优先使用组合而非继承；  
3. 使用接口。

> final方法不能被重写，final类不能被继承  
>
> 给方法加final修饰符，父类就保留了随意修改这个方法内部实现的自由，使用这个方法的程序也可以确保其行为是符合父类声明的  
>
> 使用组合可以抵挡父类变化对子类的影响，从而保护子类，应该优先使用组合

| 组 合 关 系                                                  | 继 承 关 系                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立     | 缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性 |
| 优点：具有较好的可扩展性                                     | 缺点：支持扩展，但是往往以增加系统结构的复杂度为代价         |
| 优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象 | 缺点：不支持动态继承。在运行时，子类无法选择不同的父类       |
| 优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口 | 缺点：子类不能改变父类的接口                                 |
| 缺点：整体类不能自动获得和局部类同样的接口                   | 优点：子类能自动继承父类的接口                               |
| 缺点：创建整体类的对象时，需要创建所有局部类的对象           | 优点：创建子类的对象时，无须创建父类的对象                   |