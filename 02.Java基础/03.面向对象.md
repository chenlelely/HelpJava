## 3.1 类

某些情况下，类也确实只是函数的容器，但类更多表示的是自定义数据类型

将类看作自定义数据类型，所谓自定义数据类型就是除了8种基本类型以外的其他类型，用于表示和处理基本类型以外的其他数据。  
一个数据类型由其包含的属性以及该类型可以进行的操作组成，  
属性又可以分为是类型本身具有的属性，还是一个具体实例具有的属性，  
操作也可以分为是类型本身可以进行的操作，还是一个具体实例可以进行的操作。  
这样，一个数据类型就主要由4部分组成：  
❑ 类型本身具有的属性，通过类变量体现。   
❑ 类型本身可以进行的操作，通过类方法体现。   
❑ 类型实例具有的属性，通过实例变量体现。  
❑ 类型实例可以进行的操作，通过实例方法体现。

类变量和实例变量都叫成员变量，也就是类的成员，类变量也叫静态变量或静态成员变量。类方法和实例方法都叫成员方法，也都是类的成员，类方法也叫静态方法。  
类型本身具有的属性通过类变量体现，经常用于表示一个类型中的常量。 实例变量表示具体的实例所具有的属性，实例方法表示具体的实例可以进行的操作

在实例方法中，有一个隐含的参数，这个参数就是当前操作的实例自己，直接操作实例变量，实际也需要通过参数进行。实例方法和类方法的更多区别如下所示。  
❑ 类方法只能访问类变量，不能访问实例变量，可以调用其他的类方法，不能调用实例方法。  
❑ 实例方法既能访问实例变量，也能访问类变量，既可以调用实例方法，也可以调用类方法。

定义了类本身和定义了一个函数类似，本身不会做什么事情，不会分配内存，也不会执行代码。方法要执行需要被调用，而实例方法被调用，首先需要一个实例。实例也称为对象

声明引用类型的变量本身只会分配存放`位置`的内存空间，这块空间还没有指向任何实际内容。因为这种变量和数组变量本身不存储数据，而只是存储实际内容的位置

> p = new Point()；创建了一个实例或对象，然后赋值给了Point类型的变量p，它至少做了两件事：1）分配内存，以存储新对象的数据，对象数据包括这个对象的属性，具体包括其实例变量x和y。2）给实例变量设置默认值，int类型默认值为0。

与方法内定义的局部变量不同，在创建对象的时候，所有的实例变量都会分配一个默认值，这与创建数组的时候是类似的

### 3.1.1 构造方法

1）名称是固定的，与类名相同。这也容易理解，靠这个用户和Java系统就都能容易地知道哪些是构造方法。2）没有返回值，也不能有返回值。构造方法隐含的返回值就是实例本身。与普通方法一样，构造方法也可以重载。

构造方法是用于初始化对象的，如果要调用别的构造方法，先调别的，然后根据情况自己再做调整，而如果自己先初始化了一部分，再调别的，自己的修改可能就被覆盖了。

> 没有定义任何构造方法的时候，Java认为用户不需要，所以就生成一个空的以被new过程调用；定义了构造方法的时候，Java认为用户知道自己在干什么，认为用户是有意不想要不带参数的构造方法，所以不会自动生成。

构造方法可以是私有方法，即修饰符可以为private，为什么需要私有构造方法呢？大致可能有这么几种场景：  
1）不能创建类的实例，类只能被静态访问，如Math和Arrays类，它们的构造方法就是私有的。  
2）能创建类的实例，但只能被类的静态方法调用。有一种常见的场景：类的对象有但是只能有一个，即单例（单个实例）。在这种场景中，对象是通过静态方法获取的，而静态方法调用私有构造方法创建一个对象，如果对象已经创建过了，就重用这个对象。  
3）只是用来被其他多个构造方法调用，用于减少重复代码。

在程序运行的时候，当第一次通过new创建一个类的对象时，或者直接通过类名访问类变量和类方法时，Java会将类加载进内存，为这个类分配一块空间，这个空间会包括类的定义、它的变量和方法信息，同时还有类的静态变量，并对静态变量赋初始值。  
类加载进内存后，一般不会释放，直到程序结束。一般情况下，类只会加载一次，所以静态变量在内存中只有一份。  
当通过new创建一个对象的时候，对象产生，在内存中，会存储这个对象的实例变量值，每做new操作一次，就会产生一个对象，就会有一份独立的实例变量。每个对象除了保存实例变量的值外，可以理解为还保存着对应类型即类的地址，这样，通过对象能知道它的类，访问到类的变量和方法代码。  
实例方法可以理解为一个静态方法，只是多了一个参数this。通过对象调用方法，可以理解为就是调用这个静态方法，并将对象作为参数传给this。对象的释放是被Java用垃圾回收机制管理的

对象和数组一样，有两块内存，保存地址的部分分配在栈中，而保存实际内容的部分分配在堆中。栈中的内存是自动管理的，函数调用入栈就会分配，而出栈就会释放。  
堆中的内存是被垃圾回收机制管理的，当没有活跃变量指向对象的时候，对应的堆空间就可能被释放，具体释放时间是Java虚拟机自己决定的。活跃变量就是已加载的类的类变量，以及栈中所有的变量。

## 3.2 代码的组织机制

同一个包下的类之间互相引用是不需要包名的，可以直接使用。但如果类不在同一个包内，则必须要知道其所在的包。使用有两种方式：**一种是通过类的完全限定名；另外一种是将用到的类引入当前类**

可见性范围从小到大是：**private < 默认(包) < protected < public。**

从Java源代码到运行的程序，有**编译和链接**两个步骤。  
编译是将源代码文件变成扩展名是．class的一种字节码，这个工作一般是由`javac命令`完成的。  
链接是在运行时`动态执行`的，.class文件不能直接运行，运行的是Java虚拟机，虚拟机听起来比较抽象，执行的就是`Java命令`，这个命令解析．class文件，转换为机器能识别的二进制代码，然后运行。所谓链接就是**根据引用到的类加载相应的字节码并执行**。

Java编译和运行时，都需要以参数指定一个`classpath`，即类路径。类路径可以有多个，对于直接的class文件，路径是class文件的根目录；对于jar包，路径是jar包的完整名称（包括路径和jar包名）

 在Java源代码编译时，Java编译器会确定引用的每个类的完全限定名，确定的方式是根据`import`语句和classpath。

Java运行时，会根据类的完全限定名寻找并加载类，寻找的方式就是在类路径中寻找，如果是class文件的根目录，则直接查看是否有对应的子目录及文件，如果是jar文件，则首先在内存中解压文件，然后再查看是否有对应的类。

总结来说，import是编译时概念，用于确定完全限定名，在运行时，只根据完全限定名寻找并加载类，编译和运行时都依赖类路径，类路径中的jar文件会被解压缩用于寻找和加载类。

